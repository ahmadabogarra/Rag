المطلوب:
تصميم أو تعديل واجهة إدارة المستندات لإعداد المستندات بذكاء للبحث الدلالي باستخدام نماذج التضمين وقاعدة بيانات FAISS، وفق سيناريو مرن ومتكامل يعالج التحديات الشائعة ويتضمن خيارات تخصيص متقدمة.
🧠 الخطوات الكاملة (من ما قبل الرفع إلى البحث)
قبل رفع المستند (Pre-Upload):
المرونة في الصيغ: يدعم المستخدم رفع مستندات بصيغ متنوعة:
ملفات منظمة (JSON, CSV, Excel)
ملفات شبه منظمة (HTML, XML, Markdown)
ملفات نصية حرة (TXT, PDF، DOCX)
تجميع المستندات (اختياري): إمكانية رفع مجموعة مستندات ذات صلة (مثل مشروع) ليتم التعامل معها كوحدة منطقية مبدئياً.
ما بعد الرفع - التحليل والكشف الذكي (Post-Upload - Intelligent Detection & Analysis):
استخلاص المحتوى الأولي: يتم استخلاص النص والبيانات الأولية (مثل استخلاص النص من PDF مع OCR إذا لزم الأمر، تحليل جداول HTML).
اقتراح تصنيف البنية: يقوم النظام بـ:
تحليل بنية البيانات واقتراح تصنيف للمستند:
🔵 ثابت البنية (Structured): (مثل JSON مسطح، CSV). يقترح النظام تقسيمًا سجليًا.
🟠 شبه ثابت (Semi-structured): (مثل JSON معقد، XML، Markdown منظم). يقترح النظام تقسيمًا ذكيًا مبدئيًا (مثلاً بناءً على عناصر قائمة، أو أقسام Markdown).
🔴 حر (Unstructured): (مثل مقالة، تقرير). يقترح النظام تقسيمًا بالطول.
تأكيد المستخدم: يعرض النظام التصنيف المقترح ويسمح للمستخدم بتعديله إذا لزم الأمر، مع توضيح أثر كل تصنيف على استراتيجية التقسيم.
الكشف عن اللغة (Language Detection): تحديد لغة المحتوى الأساسي لاختيار نموذج تضمين مناسب وتوكنايزر ملائم.
تحديد الحقول الوظيفية وتكوين البيانات الوصفية (Field Roles & Metadata Configuration):
عرض الحقول/الأقسام المكتشفة: يعرض النظام الحقول (للمنظمة وشبه المنظمة) أو الأقسام الرئيسية (لغير المنظمة، مثل العناوين المكتشفة) التي تمكن من تحديدها.
تحديد مصدر التضمين:
يطلب من المستخدم تحديد حقل أو أكثر ليكونوا المصدر الأساسي للتضمين.
خيار دمج الحقول: إذا تم اختيار أكثر من حقل، يمكن للمستخدم تحديد كيفية دمجهم (مثلاً: "العنوان: [محتوى العنوان]، الملخص: [محتوى الملخص]").
تحديد حقول البيانات الوصفية (Metadata):
يختار المستخدم الحقول التي ستُخزن كـ metadata للاستخدام في التصفية أو العرض.
خيار الاحتفاظ بالسجل/المستند الكامل:
تمكين خيار "الاحتفاظ بالسجل الكامل/المحتوى الأصلي في metadata" لاسترجاع كامل الإدخال.
معالجة المستندات الكبيرة: للمستندات الكبيرة جداً (خاصة غير المنظمة)، يمكن للنظام اقتراح تخزين مرجع/مؤشر للمستند الأصلي بدلاً من كامل محتواه في الـ metadata لتجنب تضخيم حجمها، أو تخزين مقتطفات رئيسية.
إضافة metadata مخصصة: السماح للمستخدم بإضافة حقول metadata ثابتة أو ديناميكية (بناءً على اسم الملف، تاريخ الرفع، إلخ).
تهيئة سياسة التقسيم (Chunking Strategy Configuration):
عرض السياسة المقترحة: يعرض النظام سياسة التقسيم الافتراضية بناءً على التصنيف الذي تم تأكيده في الخطوة (2).
تعديل المستخدم (مع توجيهات):
Structured: تقسيم كل سجل كوحدة (افتراضي). خيارات متقدمة لدمج سجلات قليلة إذا كانت صغيرة جداً.
Semi-structured:
افتراضيات ذكية (مثلاً، عناصر قائمة في JSON، أقسام Markdown).
السماح للمستخدم بتحديد محددات (delimiters) مخصصة أو مسارات (JSONPath/XPath-like) مع واجهة مرئية أو أدوات مساعدة لاختيار هذه المسارات.
Unstructured (النص الحر):
التقسيم بالطول (Token/Window-based): تحديد عدد التوكنات/الكلمات، ونسبة التداخل (overlap). (هذا هو الافتراضي المقترح).
التقسيم بناءً على تعبير نمطي (Regex-based Splitting):
السماح للمستخدم بإدخال تعبير نمطي (Regex) ليتم استخدامه كفاصل (splitter) لتقسيم النص.
خيارات إضافية للـ Regex: تحديد ما إذا كان النمط نفسه يُحتفظ به كجزء من القطعة السابقة/اللاحقة أو يُحذف.
أمثلة شائعة: توفير أمثلة Regex جاهزة (مثل: فواصل أسطر فارغة متعددة، أنماط عناوين محددة كـ "الفصل الأول:"، إلخ).
توجيهات: توضيح أن التقسيم بالـ Regex فعال للنصوص ذات الأنماط المتكررة ولكن قد ينتج عنه قطع غير متساوية الطول، مما قد يتطلب ضبطًا لـ max tokens per chunk في إعدادات النموذج لاحقًا.
معاينة التقسيم (Chunk Preview): عرض عينة من الأجزاء (chunks) الناتجة قبل تطبيق التقسيم على كامل المستند، موضحًا تأثير الإعدادات المختارة (طول، Regex، إلخ).
⚠️ تنبيه: أي تعديل في سياسة التقسيم يتطلب إعادة إنشاء التضمينات للأجزاء المتأثرة.
إعداد نموذج التضمين (Embedding Model Setup):
اختيار النموذج: يقترح النظام نماذج بناءً على اللغة المكتشفة وطبيعة البيانات (مثل e5-large, Jina Embeddings, OpenAI Ada، إلخ)، مع توضيح نقاط قوة كل نموذج.
إعدادات متقدمة (اختياري وقابل للطي): Pooling strategy, dtype, device, max tokens per chunk for model input (مع مراعاة تأثير سياسة التقسيم المختارة، خاصةً إذا كان التقسيم بالـ Regex قد ينتج قطعًا طويلة). يتم عرض القيم الافتراضية الموصى بها.
⚠️ تنبيه: تغيير النموذج أو الإعدادات الأساسية يتطلب إعادة التضمين والفهرسة بالكامل.
مرحلة التضمين (Embedding Phase):
يُنشأ تضمين من الحقل/الحقول المحددة كمصدر للمعنى (بعد دمجها إذا لزم الأمر).
كل جزء ناتج من التقسيم ← يُضمَّن بشكل مستقل.
النتيجة: قائمة سجلات تحتوي على:
vector: المتجه الناتج عن التضمين.
metadata: تشمل الحقول المحددة كـ metadata، والمحتوى الأصلي للجزء (chunk)، والسجل/المستند الكامل (أو مرجعه) إذا تم تفعيل الخيار.
الفهرسة (Indexing in FAISS):
إعدادات الفهرس:
Dimension: يتم تحديده تلقائيًا من نموذج التضمين.
Metric: (مثل L2, Inner Product) مع توصية بناءً على النموذج.
Index type: (مثل IndexFlatL2, IndexIVFPQ) مع اقتراح بناءً على حجم البيانات ومتطلبات السرعة/الدقة.
ربط المتجهات بالـ metadata: يُربط كل vector بسجل metadata المرافق له.
⚠️ تنبيه: تغيير نوع الفهرس، الأبعاد (نادرًا ما يتغير إلا بتغيير النموذج)، أو المتركية يتطلب بناء فهرس جديد.
البحث (Semantic Search):
إدخال الاستعلام: يُدخل المستخدم استعلامًا نصيًا.
تحويل الاستعلام: يُحوَّل الاستعلام إلى vector باستخدام نفس نموذج التضمين وإعداداته.
البحث في الفضاء المتجهي: يتم البحث عن أقرب المتجهات في قاعدة FAISS.
جلب وعرض النتائج:
يتم جلب metadata المرتبطة بأقرب النتائج.
يتم عرض النتائج مع إمكانية عرض الحقول المحددة كـ metadata، والمقتطف الذي تطابق، وإذا تم تفعيل خيار “استرجاع السجل الكامل” ← يُعرض كامل محتوى الإدخال الأصلي (أو رابط إليه).
التصفية المتقدمة: السماح للمستخدم بتصفية النتائج بناءً على حقول الـ metadata.
التحديثات والمعالجة التزايدية (Incremental Processing & Updates):
إضافة مستندات جديدة: تتبع نفس الخطوات من 2 إلى 7 للمستندات الجديدة، ويتم إضافتها إلى الفهرس الحالي (إذا كان نوع الفهرس يدعم ذلك بكفاءة).
تحديث مستندات موجودة: يتطلب تحديد المستند، إعادة معالجته (من الخطوة 3 أو 4 حسب التغيير)، ثم تحديث/استبدال المتجهات والـ metadata الخاصة به في الفهرس.
حذف مستندات: إزالة المتجهات والـ metadata المرتبطة بها من الفهرس (FAISS يدعم إزالة IDs).
💡 نقاط حاسمة خاصة بحالتك (معالجة معززة):
مستند JSON فيه مفاتيح متعددة لكل إدخال: كل إدخال (كائن JSON في قائمة مثلاً) يُعامل كسجل مستقل. يتم تحليل بنيته الداخلية لاقتراح حقول التضمين والـ metadata.
تضمين حقل واحد أو أكثر للبحث: يحدد المستخدم الحقل/الحقول الأهم (مثلاً الوصف + العنوان) كمصدر التضمين.
حفظ كافة الحقول للاسترجاع: يمكن تفعيل وضع كامل الإدخال داخل metadata لكل جزء، مع مراعاة حجم المستندات الكبيرة (استخدام مرجع).
منع تضخيم المعنى أثناء التضمين: بتحديد المستخدم الدقيق للحقول ذات المعنى للتضمين، وتجنب تضمين حقول تعريفية بحتة أو طويلة جدًا بشكل غير مبرر في نفس متجه الحقل الرئيسي (إلا إذا كانت جزءًا من الدمج المقصود).
دعم الفلترة لاحقًا: التأكيد على حفظ الحقول المهمة كـ metadata مفهرسة (إذا كانت قاعدة بيانات الـ metadata تدعم الفهرسة الثانوية بجانب FAISS).
✅ ملاحظات مهمة (مُعاد تأكيدها):
metadata ليست جزءًا من عملية التضمين نفسها (لا تُحول إلى vector)، بل تُستخدم للتصفية، العرض، واسترجاع السياق.
vector يتم توليده من الحقل/الحقول المحددة صراحةً من قبل المستخدم لهذا الغرض.
التقسيم (Chunking) يحدد عدد الوحدات التي سيتم تضمينها من كل مستند.
كل وحدة (chunk) = (vector + metadata خاصة بها، بالإضافة لمرجع للسجل/المستند الأم).
لا يتم تضمين كل شيء بالضرورة، ولكن يمكن استرجاع كل شيء (أو مرجعه) باستخدام الـ metadata المرتبطة.
